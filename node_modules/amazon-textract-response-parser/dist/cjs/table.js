"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableGeneric = exports.RowGeneric = exports.MergedCellGeneric = exports.CellGeneric = exports.CellBaseGeneric = void 0;
const base_1 = require("./base");
const content_1 = require("./content");
const geometry_1 = require("./geometry");
class CellBaseGeneric extends base_1.ApiBlockWrapper {
    constructor(block, parentTable) {
        super(block);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
        this._parentTable = parentTable;
    }
    get columnIndex() {
        return this._dict.ColumnIndex;
    }
    get columnSpan() {
        return this._dict.ColumnSpan || 1;
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get parentTable() {
        return this._parentTable;
    }
    get rowIndex() {
        return this._dict.RowIndex;
    }
    get rowSpan() {
        return this._dict.RowSpan || 1;
    }
}
exports.CellBaseGeneric = CellBaseGeneric;
class CellGeneric extends CellBaseGeneric {
    constructor(block, parentTable) {
        super(block, parentTable);
        const parentDocument = parentTable.parentPage.parentDocument;
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
        this._content = [];
        const texts = [];
        (block.Relationships || []).forEach((rs) => {
            if (rs.Type == "CHILD") {
                rs.Ids.forEach((cid) => {
                    const childBlock = parentDocument.getBlockById(cid);
                    if (!childBlock) {
                        console.warn(`Document missing child block ${cid} referenced by table cell ${this.id}`);
                        return;
                    }
                    const blockType = childBlock.BlockType;
                    if (blockType == "WORD") {
                        const w = new content_1.Word(childBlock);
                        this._content.push(w);
                        texts.push(w.text);
                    }
                    else if (blockType == "SELECTION_ELEMENT") {
                        const se = new content_1.SelectionElement(childBlock);
                        this._content.push(se);
                        texts.push(se.selectionStatus + ",");
                    }
                });
            }
        });
        this._text = texts.join(" ");
    }
    get text() {
        return this._text;
    }
    listContent() {
        return this._content.slice();
    }
    str() {
        return this._text;
    }
}
exports.CellGeneric = CellGeneric;
class MergedCellGeneric extends CellBaseGeneric {
    constructor(block, parentTable) {
        super(block, parentTable);
        let cells = [];
        (block.Relationships || []).forEach((rs) => {
            if (rs.Type == "CHILD") {
                cells = cells.concat(rs.Ids.map((cid) => parentTable._getSplitCellByBlockId(cid)));
            }
        });
        this._cells = cells;
    }
    get text() {
        return this._cells.map((c) => c.text).join(" ");
    }
    listContent() {
        return [].concat(...this._cells.map((c) => c.listContent()));
    }
    str() {
        return this.text;
    }
}
exports.MergedCellGeneric = MergedCellGeneric;
class RowGeneric {
    constructor(cells = [], parentTable) {
        this._cells = cells;
        this._parentTable = parentTable;
    }
    get nCells() {
        return this._cells.length;
    }
    get parentTable() {
        return this._parentTable;
    }
    iterCells() {
        return (0, base_1.getIterable)(() => this._cells);
    }
    listCells() {
        return this._cells.slice();
    }
    str() {
        return this._cells.map((cell) => `[${cell.str()}]`).join("");
    }
}
exports.RowGeneric = RowGeneric;
class TableGeneric extends base_1.ApiBlockWrapper {
    constructor(block, parentPage) {
        super(block);
        this._parentPage = parentPage;
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
        const parentDocument = parentPage.parentDocument;
        this._cells = [].concat(...(block.Relationships || [])
            .filter((rs) => rs.Type == "CHILD")
            .map((rs) => rs.Ids.map((cid) => {
            const cellBlock = parentDocument.getBlockById(cid);
            if (!cellBlock) {
                console.warn(`Document missing child block ${cid} referenced by TABLE ${this.id}`);
                return;
            }
            return new CellGeneric(cellBlock, this);
        }).filter((cell) => cell)));
        this._sortCellsByLocation(this._cells);
        this._nCols = this._cells.reduce((acc, next) => Math.max(acc, next.columnIndex + next.columnSpan - 1), 0);
        this._nRows = this._cells.reduce((acc, next) => Math.max(acc, next.rowIndex + next.rowSpan - 1), 0);
        this._cellsById = {};
        this._updateCellsById();
        this._mergedCells = [].concat(...(block.Relationships || [])
            .filter((rs) => rs.Type == "MERGED_CELL")
            .map((rs) => rs.Ids.map((cid) => {
            const cellBlock = parentDocument.getBlockById(cid);
            if (!cellBlock) {
                console.warn(`Document missing merged cell block ${cid} referenced by TABLE ${this.id}`);
                return;
            }
            return new MergedCellGeneric(cellBlock, this);
        }).filter((cell) => cell)));
    }
    _sortCellsByLocation(cells) {
        cells.sort((a, b) => a.rowIndex - b.rowIndex || a.columnIndex - b.columnIndex);
    }
    _updateCellsById() {
        this._cellsById = this._cells.reduce((acc, next) => {
            acc[next.id] = next;
            return acc;
        }, {});
    }
    _getSplitCellByBlockId(id) {
        let result = this._cellsById[id];
        if (result) {
            return result;
        }
        else {
            this._updateCellsById();
            result = this._cellsById[id];
            if (!result) {
                throw new Error(`Referenced cell ID ${id} missing from TABLE ${this.id}`);
            }
            return result;
        }
    }
    cellAt(rowIndex, columnIndex, ignoreMerged = false) {
        const mergedResult = !ignoreMerged &&
            this._mergedCells.find((c) => c.columnIndex <= columnIndex &&
                c.columnIndex + c.columnSpan > columnIndex &&
                c.rowIndex <= rowIndex &&
                c.rowIndex + c.rowSpan > rowIndex);
        if (mergedResult) {
            return mergedResult;
        }
        else {
            return this._cells.find((c) => c.columnIndex === columnIndex && c.rowIndex === rowIndex);
        }
    }
    cellsAt(rowIndex, columnIndex, ignoreMerged = false) {
        const mergedCells = ignoreMerged
            ? []
            : this._mergedCells.filter((c) => (rowIndex == null || (c.rowIndex <= rowIndex && c.rowIndex + c.rowSpan > rowIndex)) &&
                (columnIndex == null ||
                    (c.columnIndex <= columnIndex && c.columnIndex + c.columnSpan > columnIndex)));
        const mergedCellChildIds = mergedCells.reduce((acc, next) => {
            next._cells.forEach((c) => {
                acc[c.id] = true;
            });
            return acc;
        }, {});
        const rawCells = this._cells.filter((c) => (rowIndex == null || c.rowIndex === rowIndex) &&
            (columnIndex == null || c.columnIndex === columnIndex) &&
            !(c.id in mergedCellChildIds));
        const result = mergedCells.concat(rawCells);
        this._sortCellsByLocation(result);
        return result;
    }
    iterRows(repeatMultiRowCells = false) {
        const getIterator = () => {
            let ixRow = 0;
            return {
                next: () => {
                    if (ixRow < this._nRows) {
                        return {
                            done: false,
                            value: this.rowAt(++ixRow, repeatMultiRowCells),
                        };
                    }
                    else {
                        return {
                            done: true,
                            value: undefined,
                        };
                    }
                },
            };
        };
        return {
            [Symbol.iterator]: getIterator,
        };
    }
    listRows(repeatMultiRowCells = false) {
        return [...Array(this._nRows).keys()].map((ixRow) => this.rowAt(ixRow + 1, repeatMultiRowCells));
    }
    rowAt(rowIndex, repeatMultiRowCells = false) {
        const allRowCells = this.cellsAt(rowIndex, null);
        return new RowGeneric(repeatMultiRowCells ? allRowCells : allRowCells.filter((c) => c.rowIndex === rowIndex), this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get nCells() {
        return this._cells.length;
    }
    get nColumns() {
        return this._nCols;
    }
    get nRows() {
        return this._nRows;
    }
    get parentPage() {
        return this._parentPage;
    }
    str() {
        return ("Table\n==========\n" +
            this.listRows()
                .map((row) => `Row\n==========\n${row.str()}`)
                .join("\n"));
    }
}
exports.TableGeneric = TableGeneric;
//# sourceMappingURL=table.js.map