"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectionElement = exports.LineGeneric = exports.WithWords = exports.Word = void 0;
const base_1 = require("./base");
const geometry_1 = require("./geometry");
class Word extends base_1.ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get text() {
        return this._dict.Text;
    }
    get textType() {
        return this._dict.TextType;
    }
    set textType(newVal) {
        this._dict.TextType = newVal;
    }
    str() {
        return this.text;
    }
}
exports.Word = Word;
function WithWords(SuperClass) {
    return class extends SuperClass {
        constructor(...args) {
            super(...args);
            this._words = [];
        }
        get nWords() {
            return this._words.length;
        }
        iterWords() {
            return (0, base_1.getIterable)(() => this._words);
        }
        listWords() {
            return this._words.slice();
        }
        wordAtIndex(ix) {
            if (ix < 0 || ix >= this._words.length) {
                throw new Error(`Word index ${ix} must be >=0 and <${this._words.length}`);
            }
            return this._words[ix];
        }
    };
}
exports.WithWords = WithWords;
class LineGeneric extends WithWords(base_1.ApiBlockWrapper) {
    constructor(block, parentPage) {
        super(block);
        this._parentPage = parentPage;
        this._words = [];
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
        const parentDocument = parentPage.parentDocument;
        if (block.Relationships) {
            block.Relationships.forEach((rs) => {
                if (rs.Type == "CHILD") {
                    rs.Ids.forEach((cid) => {
                        const wordBlock = parentDocument.getBlockById(cid);
                        if (!wordBlock) {
                            console.warn(`Document missing word block ${cid} referenced by line ${this.id}`);
                            return;
                        }
                        if (wordBlock.BlockType == "WORD")
                            this._words.push(new Word(wordBlock));
                    });
                }
            });
        }
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get parentPage() {
        return this._parentPage;
    }
    get text() {
        return this._dict.Text;
    }
    str() {
        return `Line\n==========\n${this._dict.Text}\nWords\n----------\n${this._words
            .map((word) => `[${word.str()}]`)
            .join("")}`;
    }
}
exports.LineGeneric = LineGeneric;
class SelectionElement extends base_1.ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new geometry_1.Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get selectionStatus() {
        return this._dict.SelectionStatus;
    }
    set selectionStatus(newVal) {
        this._dict.SelectionStatus = newVal;
    }
}
exports.SelectionElement = SelectionElement;
//# sourceMappingURL=content.js.map