(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./base"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Geometry = exports.Point = exports.BoundingBox = void 0;
    const base_1 = require("./base");
    class BoundingBox extends base_1.ApiObjectWrapper {
        constructor(dict, parentGeometry = null) {
            super(dict);
            this._parentGeometry = parentGeometry;
        }
        get bottom() {
            return this.top + this.height;
        }
        get hCenter() {
            return this.left + this.width / 2;
        }
        get height() {
            return this._dict.Height;
        }
        get left() {
            return this._dict.Left;
        }
        get parentGeometry() {
            return this._parentGeometry;
        }
        get top() {
            return this._dict.Top;
        }
        get right() {
            return this.left + this.width;
        }
        get vCenter() {
            return this.top + this.height / 2;
        }
        get width() {
            return this._dict.Width;
        }
        union(other) {
            const left = Math.min(this.left, other.left);
            const top = Math.min(this.top, other.top);
            const right = Math.max(this.right, other.right);
            const bottom = Math.max(this.bottom, other.bottom);
            return new BoundingBox({
                Height: bottom - top,
                Left: left,
                Top: top,
                Width: right - left,
            }, null);
        }
        intersection(other) {
            const vIsectTop = Math.max(this.top, other.top);
            const vIsectBottom = Math.min(this.bottom, other.bottom);
            const vIsect = Math.max(0, vIsectBottom - vIsectTop);
            const hIsectLeft = Math.max(this.left, other.left);
            const hIsectRight = Math.min(this.right, other.right);
            const hIsect = Math.max(0, hIsectRight - hIsectLeft);
            if (vIsect > 0 && hIsect > 0) {
                return new BoundingBox({
                    Height: vIsectBottom - vIsectTop,
                    Left: hIsectLeft,
                    Top: vIsectTop,
                    Width: hIsectRight - hIsectLeft,
                }, null);
            }
            else {
                return null;
            }
        }
        str() {
            return `width: ${this._dict.Width}, height: ${this._dict.Height}, left: ${this._dict.Left}, top: ${this._dict.Top}`;
        }
    }
    exports.BoundingBox = BoundingBox;
    class Point extends base_1.ApiObjectWrapper {
        constructor(dict, parentGeometry = null) {
            super(dict);
            this._parentGeometry = parentGeometry;
        }
        get parentGeometry() {
            return this._parentGeometry;
        }
        get x() {
            return this._dict.X;
        }
        get y() {
            return this._dict.Y;
        }
        str() {
            return `x: ${this._dict.X}, y: ${this._dict.Y}`;
        }
    }
    exports.Point = Point;
    class Geometry extends base_1.ApiObjectWrapper {
        constructor(dict, parentObject) {
            super(dict);
            this._parentObject = parentObject;
            this._boundingBox = new BoundingBox(dict.BoundingBox, this);
            this._polygon = dict.Polygon.map((pnt) => new Point(pnt, this));
        }
        get boundingBox() {
            return this._boundingBox;
        }
        get parentObject() {
            return this._parentObject;
        }
        get polygon() {
            return this._polygon.slice();
        }
        orientationRadians() {
            if (!this._polygon || this._polygon.length < 2)
                return null;
            const point0 = this._polygon[0];
            const point1 = this._polygon[1];
            return Math.atan2(point1.y - point0.y, point1.x - point0.x);
        }
        orientationDegrees() {
            const rads = this.orientationRadians();
            if (rads == null)
                return rads;
            return (rads * 180) / Math.PI;
        }
        str() {
            return `BoundingBox: ${this._boundingBox.str()}`;
        }
    }
    exports.Geometry = Geometry;
});
//# sourceMappingURL=geometry.js.map