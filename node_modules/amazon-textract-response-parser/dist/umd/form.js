(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./base", "./content", "./geometry"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FormsCompositeGeneric = exports.FormGeneric = exports.FieldGeneric = exports.FieldValueGeneric = exports.FieldKeyGeneric = void 0;
    const base_1 = require("./base");
    const content_1 = require("./content");
    const geometry_1 = require("./geometry");
    class FieldKeyGeneric extends (0, content_1.WithWords)(base_1.ApiBlockWrapper) {
        constructor(block, parentField) {
            super(block);
            this._parentField = parentField;
            this._words = [];
            this._geometry = new geometry_1.Geometry(block.Geometry, this);
            let childIds = [];
            (block.Relationships || []).forEach((rs) => {
                if (rs.Type == "CHILD") {
                    childIds = childIds.concat(rs.Ids);
                }
            });
            const parentDocument = parentField.parentForm.parentPage.parentDocument;
            childIds
                .map((id) => {
                const block = parentDocument.getBlockById(id);
                if (!block) {
                    console.warn(`Document missing child block ${id} referenced by field key ${this.id}`);
                }
                return block;
            })
                .forEach((block) => {
                if (!block)
                    return;
                if (block.BlockType == "WORD") {
                    this._words.push(new content_1.Word(block));
                }
            });
        }
        get confidence() {
            return this._dict.Confidence;
        }
        get geometry() {
            return this._geometry;
        }
        get parentField() {
            return this._parentField;
        }
        get text() {
            return this._words.map((w) => w.text).join(" ");
        }
        str() {
            return this.text;
        }
    }
    exports.FieldKeyGeneric = FieldKeyGeneric;
    class FieldValueGeneric extends base_1.ApiBlockWrapper {
        constructor(valueBlock, parentField) {
            super(valueBlock);
            this._content = [];
            this._parentField = parentField;
            this._geometry = new geometry_1.Geometry(valueBlock.Geometry, this);
            let childIds = [];
            (valueBlock.Relationships || []).forEach((rs) => {
                if (rs.Type == "CHILD") {
                    childIds = childIds.concat(rs.Ids);
                }
            });
            const parentDocument = parentField.parentForm.parentPage.parentDocument;
            childIds
                .map((id) => {
                const block = parentDocument.getBlockById(id);
                if (!block) {
                    console.warn(`Document missing child block ${id} referenced by field value ${this.id}`);
                }
                return block;
            })
                .forEach((block) => {
                if (!block)
                    return;
                if (block.BlockType == "WORD") {
                    this._content.push(new content_1.Word(block));
                }
                else if (block.BlockType == "SELECTION_ELEMENT") {
                    this._content.push(new content_1.SelectionElement(block));
                }
            });
        }
        get confidence() {
            return this._dict.Confidence;
        }
        get geometry() {
            return this._geometry;
        }
        get parentField() {
            return this._parentField;
        }
        get text() {
            return this._content.map((c) => ("selectionStatus" in c ? c.selectionStatus : c.text)).join(" ");
        }
        listContent() {
            return this._content.slice();
        }
        str() {
            return this.text;
        }
    }
    exports.FieldValueGeneric = FieldValueGeneric;
    class FieldGeneric {
        constructor(keyBlock, parentForm) {
            this._parentForm = parentForm;
            this._value = null;
            this._key = new FieldKeyGeneric(keyBlock, this);
            let valueBlockIds = [];
            (keyBlock.Relationships || []).forEach((rs) => {
                if (rs.Type == "VALUE") {
                    valueBlockIds = valueBlockIds.concat(rs.Ids);
                }
            });
            if (valueBlockIds.length > 1) {
                const fieldLogName = this._key ? `field '${this._key.text}'` : "unnamed form field";
                console.warn(`Got ${valueBlockIds.length} value blocks for ${fieldLogName} (Expected 0-1). Including first only.`);
            }
            if (valueBlockIds.length) {
                const parentDocument = parentForm.parentPage.parentDocument;
                const valBlockId = valueBlockIds[0];
                const valBlock = parentDocument.getBlockById(valBlockId);
                if (!valBlock) {
                    console.warn(`Document missing child block ${valBlockId} referenced by value for field key ${this.key.id}`);
                }
                else {
                    this._value = new FieldValueGeneric(valBlock, this);
                }
            }
        }
        get confidence() {
            const scores = [];
            if (this._key) {
                scores.push(this._key.confidence || 0);
            }
            if (this._value) {
                scores.push(this._value.confidence || 0);
            }
            if (scores.length) {
                return scores.reduce((acc, next) => acc + next, 0) / scores.length;
            }
            else {
                return 0;
            }
        }
        get key() {
            return this._key;
        }
        get parentForm() {
            return this._parentForm;
        }
        get parentPage() {
            return this._parentForm.parentPage;
        }
        get value() {
            return this._value;
        }
        str() {
            return `\nField\n==========\nKey: ${this._key ? this._key.str() : ""}\nValue: ${this._value ? this._value.str() : ""}`;
        }
    }
    exports.FieldGeneric = FieldGeneric;
    class FormGeneric {
        constructor(keyBlocks, parentPage) {
            this._fields = [];
            this._fieldsMap = {};
            this._parentPage = parentPage;
            keyBlocks.forEach((keyBlock) => {
                const f = new FieldGeneric(keyBlock, this);
                this._fields.push(f);
                const fieldKeyText = f.key.text || "";
                if (fieldKeyText) {
                    if (fieldKeyText in this._fieldsMap) {
                        if (f.confidence > this._fieldsMap[fieldKeyText].confidence) {
                            this._fieldsMap[fieldKeyText] = f;
                        }
                    }
                    else {
                        this._fieldsMap[fieldKeyText] = f;
                    }
                }
            });
        }
        get nFields() {
            return this._fields.length;
        }
        get parentPage() {
            return this._parentPage;
        }
        getFieldByKey(key) {
            return this._fieldsMap[key] || null;
        }
        iterFields(skipFieldsWithoutKey = false) {
            return (0, base_1.getIterable)(() => this.listFields(skipFieldsWithoutKey));
        }
        listFields(skipFieldsWithoutKey = false) {
            return skipFieldsWithoutKey ? this._fields.filter((f) => f.key) : this._fields.slice();
        }
        searchFieldsByKey(key) {
            const searchKey = key.toLowerCase();
            return this._fields.filter((field) => field.key && field.key.text.toLowerCase().indexOf(searchKey) >= 0);
        }
        str() {
            return this._fields.map((f) => f.str()).join("\n");
        }
    }
    exports.FormGeneric = FormGeneric;
    class FormsCompositeGeneric {
        constructor(forms, parentDocument) {
            this._forms = forms;
            this._parentDocument = parentDocument;
        }
        get nFields() {
            return this._forms.reduce((acc, next) => acc + next.nFields, 0);
        }
        get parentDocument() {
            return this._parentDocument;
        }
        getFieldByKey(key) {
            for (const form of this._forms) {
                const result = form.getFieldByKey(key);
                if (result)
                    return result;
            }
            return null;
        }
        iterFields(skipFieldsWithoutKey = false) {
            return (0, base_1.getIterable)(() => this.listFields(skipFieldsWithoutKey));
        }
        listFields(skipFieldsWithoutKey = false) {
            const allFields = [].concat(...this._forms.map((form) => form.listFields()));
            if (skipFieldsWithoutKey) {
                return allFields.filter((f) => f.key);
            }
            else {
                return allFields;
            }
        }
        searchFieldsByKey(key) {
            return [].concat(...this._forms.map((f) => f.searchFieldsByKey(key)));
        }
        str() {
            return this._forms.map((f) => f.str()).join("\n");
        }
    }
    exports.FormsCompositeGeneric = FormsCompositeGeneric;
});
//# sourceMappingURL=form.js.map