import { ApiBlockWrapper, ApiObjectWrapper, getIterable, modalAvg, } from "./base";
import { LineGeneric } from "./content";
import { FieldGeneric, FieldKeyGeneric, FieldValueGeneric, FormsCompositeGeneric, FormGeneric } from "./form";
import { BoundingBox, Geometry } from "./geometry";
import { CellBaseGeneric, CellGeneric, MergedCellGeneric, RowGeneric, TableGeneric } from "./table";
export { ApiBlockWrapper } from "./base";
export { SelectionElement, Word } from "./content";
export class Page extends ApiBlockWrapper {
    constructor(pageBlock, blocks, parentDocument) {
        super(pageBlock);
        this._blocks = blocks;
        this._parentDocument = parentDocument;
        this._geometry = new Geometry(pageBlock.Geometry, this);
        this._content = [];
        this._lines = [];
        this._tables = [];
        this._form = new FormGeneric([], this);
        this._parse(blocks);
    }
    _parse(blocks) {
        this._content = [];
        this._lines = [];
        this._tables = [];
        const formKeyBlocks = [];
        blocks.forEach((item) => {
            if (item.BlockType == "LINE") {
                const l = new LineGeneric(item, this);
                this._lines.push(l);
                this._content.push(l);
            }
            else if (item.BlockType == "TABLE") {
                const t = new TableGeneric(item, this);
                this._tables.push(t);
                this._content.push(t);
            }
            else if (item.BlockType == "KEY_VALUE_SET") {
                if (item.EntityTypes.indexOf("KEY") >= 0) {
                    formKeyBlocks.push(item);
                }
            }
        });
        this._form = new FormGeneric(formKeyBlocks, this);
    }
    getModalWordOrientationDegrees() {
        const wordDegreesByLine = this.listLines().map((line) => line.listWords().map((word) => word.geometry.orientationDegrees()));
        const wordDegrees = []
            .concat(...wordDegreesByLine)
            .filter((n) => n != null);
        return modalAvg(wordDegrees.map((n) => Math.round(n)));
    }
    _getLineClustersByColumn({ colHOverlapThresh = 0.8, colHMultilineUnionThresh = 0.7, paraVDistTol = 0.7, paraLineHeightTol = 0.3, paraIndentThresh = 0, } = {}) {
        const paraBoxes = [];
        const paraLines = [];
        const paraTotalLineHeight = [];
        const lineHCenters = this._lines.map((l) => l.geometry.boundingBox.hCenter);
        this._lines.forEach((line, ixLine) => {
            const lineBox = line.geometry.boundingBox;
            const lineHCenter = lineHCenters[ixLine];
            let isLineHeightGarbage;
            let adjLineBox;
            if (!/[^.,_\s]/.test(line.text)) {
                isLineHeightGarbage = true;
                adjLineBox = new BoundingBox({
                    Top: lineBox.top - lineBox.height * 1.5,
                    Left: lineBox.left,
                    Height: lineBox.height * 2.5,
                    Width: lineBox.width,
                }, null);
            }
            else if (!/[^-–—=~\s]/.test(line.text)) {
                isLineHeightGarbage = true;
                adjLineBox = new BoundingBox({
                    Top: lineBox.top - lineBox.height * 0.75,
                    Left: lineBox.left,
                    Height: lineBox.height * 2.5,
                    Width: lineBox.width,
                }, null);
            }
            else if (!/[^'"`^\s]/.test(line.text)) {
                isLineHeightGarbage = true;
                adjLineBox = new BoundingBox({
                    Top: lineBox.top,
                    Left: lineBox.left,
                    Height: lineBox.height * 2.5,
                    Width: lineBox.width,
                }, null);
            }
            else if (!/[^-–—=~.,_acemnorsuvwxz+<>:;\s]/.test(line.text)) {
                isLineHeightGarbage = false;
                adjLineBox = new BoundingBox({
                    Top: lineBox.top - lineBox.height * 0.25,
                    Left: lineBox.left,
                    Height: lineBox.height * 1.25,
                    Width: lineBox.width,
                }, null);
            }
            else {
                isLineHeightGarbage = false;
                adjLineBox = lineBox;
            }
            let assignedPara = null;
            for (let ixPara = 0; ixPara < paraBoxes.length; ++ixPara) {
                const paraBox = paraBoxes[ixPara];
                const paraHCenter = paraBox.hCenter;
                const nCurrParaLines = paraLines[ixPara].length;
                let newTotalLineHeight;
                let newAvgLineHeight;
                if (isLineHeightGarbage) {
                    newAvgLineHeight = paraTotalLineHeight[ixPara] / nCurrParaLines;
                    newTotalLineHeight = newAvgLineHeight * (nCurrParaLines + 1);
                }
                else {
                    newTotalLineHeight = paraTotalLineHeight[ixPara] + adjLineBox.height;
                    newAvgLineHeight = newTotalLineHeight / (nCurrParaLines + 1);
                }
                const vDist = Math.max(0, adjLineBox.top - paraBox.bottom, paraBox.top - adjLineBox.bottom);
                let passIndentationCheck;
                if (paraIndentThresh) {
                    const paraLastLine = paraLines[ixPara][nCurrParaLines - 1];
                    const paraRefLeft = paraLastLine.geometry.boundingBox.left -
                        (nCurrParaLines === 1 ? paraIndentThresh * newAvgLineHeight : 0);
                    const vIsectTop = Math.max(adjLineBox.top, paraBox.top);
                    const vIsectBottom = Math.min(adjLineBox.bottom, paraBox.bottom);
                    const vIsect = Math.max(0, vIsectBottom - vIsectTop);
                    passIndentationCheck =
                        Math.max(0, adjLineBox.left - paraRefLeft) < paraIndentThresh * newAvgLineHeight ||
                            vIsect > 0.5 * adjLineBox.height;
                }
                else {
                    passIndentationCheck = true;
                }
                if (((lineHCenter > paraBox.left && lineHCenter < paraBox.right) ||
                    (paraHCenter > lineBox.left && paraHCenter < lineBox.right)) &&
                    vDist < newAvgLineHeight * paraVDistTol &&
                    (isLineHeightGarbage ||
                        Math.abs((newAvgLineHeight - adjLineBox.height) / newAvgLineHeight) < paraLineHeightTol) &&
                    passIndentationCheck) {
                    assignedPara = ixPara;
                    paraBoxes[ixPara] = paraBox.union(lineBox);
                    paraLines[ixPara].push(line);
                    paraTotalLineHeight[ixPara] = newTotalLineHeight;
                    break;
                }
            }
            if (assignedPara == null) {
                paraBoxes.push(new BoundingBox(lineBox.dict));
                paraLines.push([line]);
                paraTotalLineHeight.push(lineBox.height);
            }
        });
        const colBoxes = [];
        const colParas = [];
        paraLines.forEach((para, ixPara) => {
            const paraBox = paraBoxes[ixPara];
            let assignedCol = null;
            for (let ixCol = 0; ixCol < colBoxes.length; ++ixCol) {
                const colBox = colBoxes[ixCol];
                const thisColParas = colParas[ixCol];
                const vIsectTop = Math.max(colBox.top, paraBox.top);
                const vIsectBottom = Math.min(colBox.bottom, paraBox.bottom);
                const vIsect = Math.max(0, vIsectBottom - vIsectTop);
                const hIsectLeft = Math.max(colBox.left, paraBox.left);
                const hIsectRight = Math.min(colBox.right, paraBox.right);
                const hIsect = Math.max(0, hIsectRight - hIsectLeft);
                const hUnion = Math.max(colBox.right, paraBox.right) - Math.min(colBox.left, paraBox.left);
                const minWidth = Math.min(colBox.width, paraBox.width);
                const proposedColBox = colBox.union(paraBox);
                const matchingVsSingleLine = para.length === 1 || (thisColParas.length === 1 && thisColParas[0].length === 1);
                const paraLineHeight = paraTotalLineHeight[ixPara] / paraLines[ixPara].length;
                if (vIsect < paraLineHeight * 0.1 &&
                    hIsect / minWidth >= colHOverlapThresh &&
                    (matchingVsSingleLine || hIsect / hUnion >= colHMultilineUnionThresh) &&
                    hIsect / minWidth >= colHOverlapThresh &&
                    colBoxes.filter((cbox) => cbox.intersection(proposedColBox)).length === 1) {
                    assignedCol = ixCol;
                    colBoxes[ixCol] = colBox.union(paraBox);
                    colParas[ixCol].push(para);
                    break;
                }
            }
            if (assignedCol == null) {
                colBoxes.push(new BoundingBox(paraBox.dict));
                colParas.push([para]);
            }
        });
        return colParas;
    }
    getLineClustersInReadingOrder({ colHOverlapThresh = 0.8, colHMultilineUnionThresh = 0.7, paraVDistTol = 0.7, paraLineHeightTol = 0.3, paraIndentThresh = 0, } = {}) {
        return [].concat(...this._getLineClustersByColumn({
            colHOverlapThresh,
            colHMultilineUnionThresh,
            paraVDistTol,
            paraLineHeightTol,
            paraIndentThresh,
        }));
    }
    getTextInReadingOrder({ colHOverlapThresh = 0.8, colHMultilineUnionThresh = 0.7, paraVDistTol = 0.7, paraLineHeightTol = 0.3, paraIndentThresh = 0, } = {}) {
        return this.getLineClustersInReadingOrder({
            colHOverlapThresh,
            colHMultilineUnionThresh,
            paraVDistTol,
            paraLineHeightTol,
            paraIndentThresh,
        })
            .map((lines) => lines.map((l) => l.text).join("\n"))
            .join("\n\n");
    }
    _groupLinesByVerticalGaps(focusTop, focusHeight, lines) {
        let vGaps = [
            new BoundingBox({
                Top: focusTop,
                Left: this._geometry.boundingBox.left,
                Height: focusHeight,
                Width: this._geometry.boundingBox.width,
            }, null),
        ];
        let preGapLineLists = [[]];
        let postLines = [];
        (lines || this._lines).forEach((line) => {
            const lineBox = line.geometry.boundingBox;
            if (lineBox.top > vGaps[vGaps.length - 1].bottom) {
                postLines.push(line);
                return;
            }
            else if (lineBox.bottom < vGaps[0].top) {
                preGapLineLists[0].push(line);
                return;
            }
            const nextGaps = [];
            const nextPreGapLineLists = [];
            let orphanedLines = [];
            let lineAssigned = false;
            for (let ixGap = 0; ixGap < vGaps.length; ++ixGap) {
                const gap = vGaps[ixGap];
                const preGapLineList = preGapLineLists[ixGap];
                const isect = lineBox.intersection(gap);
                if (!isect) {
                    nextGaps.push(gap);
                    nextPreGapLineLists.push(orphanedLines.concat(preGapLineList));
                    orphanedLines = [];
                    continue;
                }
                else if (isect.top === gap.top && isect.height === gap.height) {
                    orphanedLines = orphanedLines.concat(preGapLineList);
                    continue;
                }
                else if (isect.top > gap.top && isect.bottom < gap.bottom) {
                    nextGaps.push(new BoundingBox({
                        Top: gap.top,
                        Left: gap.left,
                        Height: isect.top - gap.top,
                        Width: gap.width,
                    }, null));
                    nextPreGapLineLists.push(orphanedLines.concat(preGapLineList));
                    orphanedLines = [];
                    nextGaps.push(new BoundingBox({
                        Top: isect.bottom,
                        Left: gap.left,
                        Height: gap.bottom - isect.bottom,
                        Width: gap.width,
                    }, null));
                    nextPreGapLineLists.push([line]);
                    lineAssigned = true;
                }
                else {
                    const preGapLines = orphanedLines.concat(preGapLineList);
                    if (isect.top === gap.top) {
                        preGapLines.push(line);
                        lineAssigned = true;
                        nextGaps.push(new BoundingBox({
                            Top: gap.top + isect.height,
                            Left: gap.left,
                            Height: gap.height - isect.height,
                            Width: gap.width,
                        }, null));
                    }
                    else {
                        nextGaps.push(new BoundingBox({
                            Top: gap.top,
                            Left: gap.left,
                            Height: isect.top - gap.top,
                            Width: gap.width,
                        }, null));
                    }
                    nextPreGapLineLists.push(preGapLines);
                    orphanedLines = [];
                }
            }
            vGaps = nextGaps;
            preGapLineLists = nextPreGapLineLists;
            postLines = orphanedLines.concat(postLines);
            if (!lineAssigned) {
                const followGapIx = vGaps.findIndex((gap) => gap.top >= lineBox.bottom);
                if (followGapIx < 0) {
                    postLines.push(line);
                }
                else {
                    preGapLineLists[followGapIx].push(line);
                }
            }
        });
        return {
            vGaps,
            lines: preGapLineLists.concat([postLines]),
        };
    }
    _getHeaderOrFooterLines(isHeader, { maxMargin = 0.16, minGap = 0.8 } = {}, fromLines) {
        const { vGaps, lines: linesByGap } = this._groupLinesByVerticalGaps(isHeader ? this._geometry.boundingBox.top : this._geometry.boundingBox.bottom - maxMargin, maxMargin, fromLines);
        const lineGroupAvgHeights = linesByGap.map((lines) => lines.length ? lines.reduce((acc, l) => acc + l.geometry.boundingBox.height, 0) / lines.length : null);
        const nonNullLineGroupAvgHeights = lineGroupAvgHeights.filter((h) => h);
        const defaultLineHeight = nonNullLineGroupAvgHeights.reduce((acc, h) => acc + h, 0) / nonNullLineGroupAvgHeights.length;
        const gapAvgLineHeights = vGaps.map((_, ixGap) => {
            const components = [];
            const preGapHeight = lineGroupAvgHeights[ixGap];
            if (preGapHeight)
                components.push(preGapHeight);
            const postGapHeight = lineGroupAvgHeights[ixGap + 1];
            if (postGapHeight)
                components.push(postGapHeight);
            if (components.length) {
                return components.reduce((acc, h) => acc + h, 0) / components.length;
            }
            else {
                return defaultLineHeight;
            }
        });
        if (isHeader) {
            const ixSplit = vGaps.findIndex((gap, ixGap) => (ixGap > 0 || linesByGap[ixGap].length) && gap.height >= gapAvgLineHeights[ixGap] * minGap);
            return ixSplit < 0 ? [] : [].concat(...linesByGap.slice(0, ixSplit + 1));
        }
        else {
            const revLinesBygap = linesByGap.slice().reverse();
            const revGapAvgLineHeights = gapAvgLineHeights.slice().reverse();
            const ixRevSplit = vGaps
                .slice()
                .reverse()
                .findIndex((gap, ixGap) => (ixGap > 0 || revLinesBygap[ixGap].length) && gap.height >= revGapAvgLineHeights[ixGap] * minGap);
            return ixRevSplit < 0
                ? []
                : [].concat(...linesByGap.slice(vGaps.length - ixRevSplit));
        }
    }
    getFooterLines(config = {}, fromLines) {
        return this._getHeaderOrFooterLines(false, config, fromLines);
    }
    getHeaderLines(config = {}, fromLines) {
        return this._getHeaderOrFooterLines(true, config, fromLines);
    }
    getLinesByLayoutArea(inReadingOrder = false, headerConfig = {}, footerConfig = {}) {
        const sourceLines = inReadingOrder
            ? [].concat(...(inReadingOrder === true
                ? this.getLineClustersInReadingOrder()
                : this.getLineClustersInReadingOrder(inReadingOrder)))
            : this._lines;
        const sourceLineSortOrder = sourceLines.reduce((acc, next, ix) => {
            acc[next.id] = ix;
            return acc;
        }, {});
        const header = this._getHeaderOrFooterLines(true, headerConfig, sourceLines).sort((a, b) => sourceLineSortOrder[a.id] - sourceLineSortOrder[b.id]);
        let usedIds = header.reduce((acc, next) => {
            acc[next.id] = true;
            return acc;
        }, {});
        const footer = this._getHeaderOrFooterLines(false, footerConfig, sourceLines.filter((l) => !(l.id in usedIds))).sort((a, b) => sourceLineSortOrder[a.id] - sourceLineSortOrder[b.id]);
        usedIds = footer.reduce((acc, next) => {
            acc[next.id] = true;
            return acc;
        }, usedIds);
        return {
            header,
            content: sourceLines
                .filter((l) => !(l.id in usedIds))
                .sort((a, b) => sourceLineSortOrder[a.id] - sourceLineSortOrder[b.id]),
            footer,
        };
    }
    iterLines() {
        return getIterable(() => this._lines);
    }
    iterTables() {
        return getIterable(() => this._tables);
    }
    lineAtIndex(ix) {
        if (ix < 0 || ix >= this._lines.length) {
            throw new Error(`Line index ${ix} must be >=0 and <${this._lines.length}`);
        }
        return this._lines[ix];
    }
    listBlocks() {
        return this._blocks.slice();
    }
    listLines() {
        return this._lines.slice();
    }
    listTables() {
        return this._tables.slice();
    }
    tableAtIndex(ix) {
        if (ix < 0 || ix >= this._tables.length) {
            throw new Error(`Table index ${ix} must be >=0 and <${this._tables.length}`);
        }
        return this._tables[ix];
    }
    get form() {
        return this._form;
    }
    get geometry() {
        return this._geometry;
    }
    get nLines() {
        return this._lines.length;
    }
    get nTables() {
        return this._tables.length;
    }
    get pageNumber() {
        const pageIndex = this._parentDocument._pages.indexOf(this);
        if (pageIndex < 0) {
            throw new Error("parentDocument does not seem to contain this Page");
        }
        else {
            return pageIndex + 1;
        }
    }
    get parentDocument() {
        return this._parentDocument;
    }
    get text() {
        return this._lines.map((l) => l.text).join("\n");
    }
    str() {
        return `Page\n==========\n${this._content.join("\n")}\n`;
    }
}
export class Line extends LineGeneric {
}
export class Field extends FieldGeneric {
}
export class FieldKey extends FieldKeyGeneric {
}
export class FieldValue extends FieldValueGeneric {
}
export class Form extends FormGeneric {
}
export class Cell extends CellGeneric {
}
export class CellBase extends CellBaseGeneric {
}
export class MergedCell extends MergedCellGeneric {
}
export class Row extends RowGeneric {
}
export class Table extends TableGeneric {
}
export class TextractDocument extends ApiObjectWrapper {
    constructor(textractResults) {
        var _a;
        let dict;
        if (Array.isArray(textractResults)) {
            dict = TextractDocument._consolidateMultipleResponses(textractResults);
        }
        else {
            if (!("Blocks" in textractResults && ((_a = textractResults.Blocks) === null || _a === void 0 ? void 0 : _a.length))) {
                throw new Error(`Provided Textract JSON has no content! (.Blocks array)`);
            }
            dict = textractResults;
        }
        super(dict);
        if ("NextToken" in this._dict) {
            console.warn(`Provided Textract JSON contains a NextToken: Content may be truncated!`);
        }
        this._blockMap = {};
        this._pages = [];
        this._form = new FormsCompositeGeneric([], this);
        this._parse();
    }
    _parse() {
        this._blockMap = this._dict.Blocks.reduce((acc, next) => {
            acc[next.Id] = next;
            return acc;
        }, {});
        let currentPageBlock = null;
        let currentPageContent = [];
        this._pages = [];
        this._dict.Blocks.forEach((block) => {
            if (block.BlockType == "PAGE") {
                if (currentPageBlock) {
                    this._pages.push(new Page(currentPageBlock, currentPageContent, this));
                }
                currentPageBlock = block;
                currentPageContent = [block];
            }
            else {
                currentPageContent.push(block);
            }
        });
        if (currentPageBlock) {
            this._pages.push(new Page(currentPageBlock, currentPageContent, this));
        }
        this._form = new FormsCompositeGeneric(this._pages.map((p) => p.form), this);
    }
    static _consolidateMultipleResponses(textractResultArray) {
        if (!(textractResultArray === null || textractResultArray === void 0 ? void 0 : textractResultArray.length))
            throw new Error(`Input Textract Results list empty!`);
        let nPages = 0;
        const docMetadata = { Pages: 0 };
        let blocks = [];
        let modelVersion = "";
        let analysisType = null;
        let jobStatus = null;
        let jobStatusMessage = null;
        let warnings = null;
        for (const textractResult of textractResultArray) {
            if ("Blocks" in textractResult && textractResult.Blocks) {
                blocks = blocks.concat(textractResult.Blocks);
            }
            else {
                console.warn("Found Textract response with no content");
            }
            if ("DocumentMetadata" in textractResult) {
                Object.assign(docMetadata, textractResult["DocumentMetadata"]);
                nPages = Math.max(nPages, textractResult.DocumentMetadata.Pages);
            }
            if ("AnalyzeDocumentModelVersion" in textractResult) {
                if (analysisType && analysisType !== "AnalyzeDocument") {
                    throw new Error("Inconsistent textractResults contain both AnalyzeDocument and DetectText results");
                }
                analysisType = "AnalyzeDocument";
                if (modelVersion && modelVersion !== textractResult.AnalyzeDocumentModelVersion) {
                    console.warn(`Inconsistent Textract model versions ${modelVersion} and ${textractResult.AnalyzeDocumentModelVersion}: Ignoring latter`);
                }
                else {
                    modelVersion = textractResult.AnalyzeDocumentModelVersion;
                }
            }
            if ("DetectDocumentTextModelVersion" in textractResult) {
                if (analysisType && analysisType !== "DetectText") {
                    throw new Error("Inconsistent textractResults contain both AnalyzeDocument and DetectText results");
                }
                analysisType = "DetectText";
                if (modelVersion && modelVersion !== textractResult.DetectDocumentTextModelVersion) {
                    console.warn(`Inconsistent Textract model versions ${modelVersion} and ${textractResult.DetectDocumentTextModelVersion}: Ignoring latter`);
                }
                else {
                    modelVersion = textractResult.DetectDocumentTextModelVersion;
                }
            }
            if ("JobStatus" in textractResult) {
                if (textractResult.JobStatus == "FAILED" ||
                    (textractResult.JobStatus || "").toLocaleUpperCase().indexOf("FAIL") >= 0) {
                    throw new Error(`Textract results contain failed job of status ${textractResult.JobStatus}`);
                }
                else if (jobStatus && jobStatus !== textractResult.JobStatus) {
                    throw new Error(`Textract results inconsistent JobStatus values ${jobStatus}, ${textractResult.JobStatus}`);
                }
                jobStatus = textractResult.JobStatus;
            }
            if ("StatusMessage" in textractResult && textractResult.StatusMessage) {
                if (jobStatusMessage && textractResult.StatusMessage !== jobStatusMessage) {
                    console.warn(`Multiple StatusMessages in Textract results - keeping longest`);
                    if (textractResult.StatusMessage.length > jobStatusMessage.length) {
                        jobStatusMessage = textractResult.StatusMessage;
                    }
                }
                else {
                    jobStatusMessage = textractResult.StatusMessage;
                }
            }
            if ("Warnings" in textractResult && textractResult.Warnings) {
                warnings = warnings ? warnings.concat(textractResult.Warnings) : textractResult.Warnings;
            }
        }
        const content = {
            DocumentMetadata: docMetadata,
            Blocks: blocks,
        };
        const modelVersionFields = analysisType == "AnalyzeDocument"
            ? { AnalyzeDocumentModelVersion: modelVersion }
            : analysisType == "DetectText"
                ? { DetectDocumentTextModelVersion: modelVersion }
                : { AnalyzeDocumentModelVersion: modelVersion || "Unknown" };
        const jobStatusFields = jobStatus ? { JobStatus: jobStatus } : {};
        const statusMessageFields = jobStatusMessage ? { StatusMessage: jobStatusMessage } : {};
        const warningFields = warnings ? { ArfBarf: warnings } : {};
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, content), modelVersionFields), jobStatusFields), statusMessageFields), warningFields);
    }
    get form() {
        return this._form;
    }
    get nPages() {
        return this._pages.length;
    }
    getBlockById(blockId) {
        return this._blockMap && this._blockMap[blockId];
    }
    iterPages() {
        return getIterable(() => this._pages);
    }
    listBlocks() {
        return this._dict.Blocks.slice();
    }
    listPages() {
        return this._pages.slice();
    }
    pageNumber(pageNum) {
        if (!(pageNum >= 1 && pageNum <= this._pages.length)) {
            throw new Error(`pageNum ${pageNum} must be between 1 and ${this._pages.length}`);
        }
        return this._pages[pageNum - 1];
    }
    str() {
        return `\nDocument\n==========\n${this._pages.map((p) => p.str()).join("\n\n")}\n\n`;
    }
}
export class FormsComposite extends FormsCompositeGeneric {
}
//# sourceMappingURL=document.js.map