import { ApiBlockWrapper, getIterable } from "./base";
import { Geometry } from "./geometry";
export class Word extends ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get text() {
        return this._dict.Text;
    }
    get textType() {
        return this._dict.TextType;
    }
    set textType(newVal) {
        this._dict.TextType = newVal;
    }
    str() {
        return this.text;
    }
}
export function WithWords(SuperClass) {
    return class extends SuperClass {
        constructor(...args) {
            super(...args);
            this._words = [];
        }
        get nWords() {
            return this._words.length;
        }
        iterWords() {
            return getIterable(() => this._words);
        }
        listWords() {
            return this._words.slice();
        }
        wordAtIndex(ix) {
            if (ix < 0 || ix >= this._words.length) {
                throw new Error(`Word index ${ix} must be >=0 and <${this._words.length}`);
            }
            return this._words[ix];
        }
    };
}
export class LineGeneric extends WithWords(ApiBlockWrapper) {
    constructor(block, parentPage) {
        super(block);
        this._parentPage = parentPage;
        this._words = [];
        this._geometry = new Geometry(block.Geometry, this);
        const parentDocument = parentPage.parentDocument;
        if (block.Relationships) {
            block.Relationships.forEach((rs) => {
                if (rs.Type == "CHILD") {
                    rs.Ids.forEach((cid) => {
                        const wordBlock = parentDocument.getBlockById(cid);
                        if (!wordBlock) {
                            console.warn(`Document missing word block ${cid} referenced by line ${this.id}`);
                            return;
                        }
                        if (wordBlock.BlockType == "WORD")
                            this._words.push(new Word(wordBlock));
                    });
                }
            });
        }
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get parentPage() {
        return this._parentPage;
    }
    get text() {
        return this._dict.Text;
    }
    str() {
        return `Line\n==========\n${this._dict.Text}\nWords\n----------\n${this._words
            .map((word) => `[${word.str()}]`)
            .join("")}`;
    }
}
export class SelectionElement extends ApiBlockWrapper {
    constructor(block) {
        super(block);
        this._geometry = new Geometry(block.Geometry, this);
    }
    get confidence() {
        return this._dict.Confidence;
    }
    set confidence(newVal) {
        this._dict.Confidence = newVal;
    }
    get geometry() {
        return this._geometry;
    }
    get selectionStatus() {
        return this._dict.SelectionStatus;
    }
    set selectionStatus(newVal) {
        this._dict.SelectionStatus = newVal;
    }
}
//# sourceMappingURL=content.js.map