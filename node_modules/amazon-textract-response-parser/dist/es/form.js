import { ApiBlockWrapper, getIterable } from "./base";
import { SelectionElement, Word, WithWords } from "./content";
import { Geometry } from "./geometry";
export class FieldKeyGeneric extends WithWords(ApiBlockWrapper) {
    constructor(block, parentField) {
        super(block);
        this._parentField = parentField;
        this._words = [];
        this._geometry = new Geometry(block.Geometry, this);
        let childIds = [];
        (block.Relationships || []).forEach((rs) => {
            if (rs.Type == "CHILD") {
                childIds = childIds.concat(rs.Ids);
            }
        });
        const parentDocument = parentField.parentForm.parentPage.parentDocument;
        childIds
            .map((id) => {
            const block = parentDocument.getBlockById(id);
            if (!block) {
                console.warn(`Document missing child block ${id} referenced by field key ${this.id}`);
            }
            return block;
        })
            .forEach((block) => {
            if (!block)
                return;
            if (block.BlockType == "WORD") {
                this._words.push(new Word(block));
            }
        });
    }
    get confidence() {
        return this._dict.Confidence;
    }
    get geometry() {
        return this._geometry;
    }
    get parentField() {
        return this._parentField;
    }
    get text() {
        return this._words.map((w) => w.text).join(" ");
    }
    str() {
        return this.text;
    }
}
export class FieldValueGeneric extends ApiBlockWrapper {
    constructor(valueBlock, parentField) {
        super(valueBlock);
        this._content = [];
        this._parentField = parentField;
        this._geometry = new Geometry(valueBlock.Geometry, this);
        let childIds = [];
        (valueBlock.Relationships || []).forEach((rs) => {
            if (rs.Type == "CHILD") {
                childIds = childIds.concat(rs.Ids);
            }
        });
        const parentDocument = parentField.parentForm.parentPage.parentDocument;
        childIds
            .map((id) => {
            const block = parentDocument.getBlockById(id);
            if (!block) {
                console.warn(`Document missing child block ${id} referenced by field value ${this.id}`);
            }
            return block;
        })
            .forEach((block) => {
            if (!block)
                return;
            if (block.BlockType == "WORD") {
                this._content.push(new Word(block));
            }
            else if (block.BlockType == "SELECTION_ELEMENT") {
                this._content.push(new SelectionElement(block));
            }
        });
    }
    get confidence() {
        return this._dict.Confidence;
    }
    get geometry() {
        return this._geometry;
    }
    get parentField() {
        return this._parentField;
    }
    get text() {
        return this._content.map((c) => ("selectionStatus" in c ? c.selectionStatus : c.text)).join(" ");
    }
    listContent() {
        return this._content.slice();
    }
    str() {
        return this.text;
    }
}
export class FieldGeneric {
    constructor(keyBlock, parentForm) {
        this._parentForm = parentForm;
        this._value = null;
        this._key = new FieldKeyGeneric(keyBlock, this);
        let valueBlockIds = [];
        (keyBlock.Relationships || []).forEach((rs) => {
            if (rs.Type == "VALUE") {
                valueBlockIds = valueBlockIds.concat(rs.Ids);
            }
        });
        if (valueBlockIds.length > 1) {
            const fieldLogName = this._key ? `field '${this._key.text}'` : "unnamed form field";
            console.warn(`Got ${valueBlockIds.length} value blocks for ${fieldLogName} (Expected 0-1). Including first only.`);
        }
        if (valueBlockIds.length) {
            const parentDocument = parentForm.parentPage.parentDocument;
            const valBlockId = valueBlockIds[0];
            const valBlock = parentDocument.getBlockById(valBlockId);
            if (!valBlock) {
                console.warn(`Document missing child block ${valBlockId} referenced by value for field key ${this.key.id}`);
            }
            else {
                this._value = new FieldValueGeneric(valBlock, this);
            }
        }
    }
    get confidence() {
        const scores = [];
        if (this._key) {
            scores.push(this._key.confidence || 0);
        }
        if (this._value) {
            scores.push(this._value.confidence || 0);
        }
        if (scores.length) {
            return scores.reduce((acc, next) => acc + next, 0) / scores.length;
        }
        else {
            return 0;
        }
    }
    get key() {
        return this._key;
    }
    get parentForm() {
        return this._parentForm;
    }
    get parentPage() {
        return this._parentForm.parentPage;
    }
    get value() {
        return this._value;
    }
    str() {
        return `\nField\n==========\nKey: ${this._key ? this._key.str() : ""}\nValue: ${this._value ? this._value.str() : ""}`;
    }
}
export class FormGeneric {
    constructor(keyBlocks, parentPage) {
        this._fields = [];
        this._fieldsMap = {};
        this._parentPage = parentPage;
        keyBlocks.forEach((keyBlock) => {
            const f = new FieldGeneric(keyBlock, this);
            this._fields.push(f);
            const fieldKeyText = f.key.text || "";
            if (fieldKeyText) {
                if (fieldKeyText in this._fieldsMap) {
                    if (f.confidence > this._fieldsMap[fieldKeyText].confidence) {
                        this._fieldsMap[fieldKeyText] = f;
                    }
                }
                else {
                    this._fieldsMap[fieldKeyText] = f;
                }
            }
        });
    }
    get nFields() {
        return this._fields.length;
    }
    get parentPage() {
        return this._parentPage;
    }
    getFieldByKey(key) {
        return this._fieldsMap[key] || null;
    }
    iterFields(skipFieldsWithoutKey = false) {
        return getIterable(() => this.listFields(skipFieldsWithoutKey));
    }
    listFields(skipFieldsWithoutKey = false) {
        return skipFieldsWithoutKey ? this._fields.filter((f) => f.key) : this._fields.slice();
    }
    searchFieldsByKey(key) {
        const searchKey = key.toLowerCase();
        return this._fields.filter((field) => field.key && field.key.text.toLowerCase().indexOf(searchKey) >= 0);
    }
    str() {
        return this._fields.map((f) => f.str()).join("\n");
    }
}
export class FormsCompositeGeneric {
    constructor(forms, parentDocument) {
        this._forms = forms;
        this._parentDocument = parentDocument;
    }
    get nFields() {
        return this._forms.reduce((acc, next) => acc + next.nFields, 0);
    }
    get parentDocument() {
        return this._parentDocument;
    }
    getFieldByKey(key) {
        for (const form of this._forms) {
            const result = form.getFieldByKey(key);
            if (result)
                return result;
        }
        return null;
    }
    iterFields(skipFieldsWithoutKey = false) {
        return getIterable(() => this.listFields(skipFieldsWithoutKey));
    }
    listFields(skipFieldsWithoutKey = false) {
        const allFields = [].concat(...this._forms.map((form) => form.listFields()));
        if (skipFieldsWithoutKey) {
            return allFields.filter((f) => f.key);
        }
        else {
            return allFields;
        }
    }
    searchFieldsByKey(key) {
        return [].concat(...this._forms.map((f) => f.searchFieldsByKey(key)));
    }
    str() {
        return this._forms.map((f) => f.str()).join("\n");
    }
}
//# sourceMappingURL=form.js.map